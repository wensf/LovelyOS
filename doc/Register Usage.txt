

程序寄存器是唯一一个被所有过程共享的资源。
虽然在给定时刻只能有一个过程是活动的，我们必须保证当一个过程（调用者）调用另一个（被调用者）时，被调用者不会覆盖某个调用者稍后会使用的寄存器的值。
为此，IA32采用了一组统一的寄存器使用惯例，所有的过程都必须遵守，包括程序库中的过程。


根据惯例，寄存器eax，edx，ecx被划分为调用者保存（caller save）寄存器。
当过程P调用Q时，Q可以覆盖这些寄存器，而不会破坏P所需要的数据。
另外，寄存器ebx，esi和edi被划分为被调用者保存（callee save）寄存器。
这意味着Q必须在覆盖它们之前，将这些寄存器的值保存到栈中，并在返回前恢复它们，因为P（或某个更高层次的过程）可能会在今后的计算中需要这些值。
此外，根据这里描述的惯例，必须保存寄存器ebp，esp。


过程P在调用Q之前计算y，但是它必须保证y的值在Q返回后是可用的。
有两种方式可以做到这一点：

1：它可以在调用Q之前，将y的值存放在自己的栈帧中；当Q返回时，它可以从栈中取出y的值。


2：它可以将y的值保存在被调用者保存寄存器中。
如果Q，或任何其他Q调用的程序，想使用这个寄存器，它必须将这个寄存器的值保存在栈帧中，并在返回前恢复该值。
因此，当Q返回到P时，y的值会在被调用者保存寄存器中，或者是因为寄存器根本就没有改变，或者是因为它被保存并恢复了。

